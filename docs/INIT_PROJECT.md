URL lesson
====

    https://habrahabr.ru/company/mailru/blog/303456/

Init
====

    npm init -y
###### В созданной папке пока что лежит одинокий файл package.json. 

Писать код мы будем в спецификации ES6. 
Хотя Node начиная с версии 4.0.0 поддерживает много возможностей ES6, 
необходимые нам модули все же остались за бортом. 
Поэтому нам нужно добавить в наш проект Babel, чтобы мы могли воспользоваться всей мощью ES6 и транспилировать 
код в ES5
>   npm install --save-dev babel-core babel-cli babel-preset-es2015

###### Также нам понадобятся библиотеки для написания unit тестов: 

>   npm install --save-dev mocha chai

В качестве фреймворка для тестирования будем использовать Mocha. Внутри тестов будем использовать Chai в роли библиотеки для проверки ожидаемого поведения и состояний. Запускать тесты мы будем с помощью команды mocha:

    ./node_modules/mocha/bin/mocha --compilers js:babel-core/register --recursive

После этого Mocha будет рекурсивно искать все тесты проекта и запускать их. Для транспилинга ES6-кода перед его запуском будет использоваться Babel. Для удобства можно хранить эту команду в package.json:

    package.json
    "scripts": {
      "test": "mocha --compilers js:babel-core/register --recursive"
    },

Теперь нам нужно включить в Babel поддержку ES6/ES2015. Для этого активируем уже установленный нами пакет babel-preset-es2015. Далее просто добавим в package.json секцию "babel":
    
    package.json
    "babel": {
      "presets": ["es2015"]
    }
    
Теперь с помощью команды npm мы можем запускать наши тесты:

    npm run test

Команда test:watch может использоваться для запуска процесса, отслеживающего изменения в нашем коде и запускающего тесты после каждого изменения:

    package.json
    "scripts": {
      "test": "mocha --compilers js:babel-core/register --recursive",
      "test:watch": "npm run test -- --watch"
    },
    
Разработанная в Facebook библиотека Immutable предоставляет нам ряд полезных структур данных. Мы обсудим её в следующей главе, а пока просто добавим в проект наряду с библиотекой chai-immutable, которая добавляет в Chai поддержку сравнения Immutable-структур:
    npm install --save immutable
    npm install --save-dev chai-immutable
Подключать chai-immutable нужно до запуска каких-либо тестов. Сделать это можно с помощью файла test_helper:
 
    import chai from 'chai';
    import chaiImmutable from 'chai-immutable';
    chai.use(chaiImmutable);

Теперь сделаем так, чтобы Mocha подгрузил этот файл до запуска тестов:

    package.json
    "scripts": {
      "test": "mocha --compilers js:babel-core/register --require ./test/test_helper.js  --recursive",
      "test:watch": "npm run test -- --watch"
    },

Хорошая ли это идея? Обычно сразу указывают на то, что если все состояния хранятся в одном дереве и вы вносите все эти безопасные обновления, то можно без особых усилий сохранять историю состояний приложения. Это позволяет реализовать undo/redo “бесплатно” — можно просто задать предыдущее или следующее состояние (дерево) из истории. Также можно сериализовать историю и сохранить её на будущее, или поместить ее в хранилище для последующего проигрывания, что может оказать неоценимую помощью в отладке.

Но мне кажется, что, помимо всех этих дополнительных возможностей, главное достоинство использование неизменяемых данных заключается в упрощении кода. Вам приходится программировать чистые функции: они только принимают и возвращают данные, и больше ничего. Эти функции ведут себя предсказуемо. Вы можете вызывать их сколько угодно раз, и они всегда будут вести себя одинаково. Давайте им одни и те же аргументы, и будете получать одни и те же результаты. Тестирование становится тривиальным, ведь вам не нужно настраивать заглушки или иные фальшивки, чтобы «подготовить вселенную» к вызову функции. Есть просто входные и выходные данные.

Поскольку мы будем описывать состояние нашего приложения неизменяемыми структурами, давайте потратим немного времени на знакомство с ними, написав несколько unit-тестов, иллюстрирующих работу. 

Если же вы уверенно работаете с неизменяемыми данными и библиотекой Immutable, то можете приступить к следующему разделу. 

Для ознакомления с идеей неизменяемости можно для начала поговорить о простейшей структуре данных. Допустим, у вас есть приложение-счётчик, состояние которого представляет собой число. Скажем, оно меняется от 0 до 1, потом до 2, потом до 3 и т.д. В принципе, мы уже думаем о числах как о неизменяемых данных. Когда счётчик увеличивается, то число не изменяется. Да это и невозможно, ведь у чисел нет «сеттеров». Вы не можете сказать 42.setValue(43). 

Так что мы просто получаем другое число, прибавляя к предыдущему единицу. Это можно сделать с помощью чистой функции. Её аргументом будет текущее состояние, а возвращаемое значение будет использоваться в качестве следующего состояния. Вызываемая функция не меняет текущее состояние. Вот её пример, а также unit тест к ней:

    test/immutable_spec.js
    import {expect} from 'chai';
    
    describe('immutability', () => {
    
      describe('a number', () => {
    
        function increment(currentState) {
          return currentState + 1;
        }
    
        it('is immutable', () => {
          let state = 42;
          let nextState = increment(state);
    
          expect(nextState).to.equal(43);
          expect(state).to.equal(42);
        });
    
      });
    
    });
    
###### Перед созданием Store нам нужно добавить Redux в проект:
> npm install --save redux

###### Добавляем Socket.io в проект:
